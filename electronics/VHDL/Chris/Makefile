# The name of the project.
PROJ := thunderbots

# The names of all the top-level test targets.
SIM_TARGETS := graycountertest serialreceivertest serialtransmittertest xbeebytereceivertest xbeebytetransmittertest sumultipliertest ssmultipliertest

# The path to the Xilinx settings32.sh file.
XILINX_SETTINGS ?= /opt/xilinx/settings32.sh

# Gather all the VHDL source files in the three directories.
VHDs_common := $(shell find common -name .svn -prune -o -name '*.vhd' -print)
VHDs_sim    := $(shell find sim    -name .svn -prune -o -name '*.vhd' -print)
VHDs_synth  := $(shell find synth  -name .svn -prune -o -name '*.vhd' -print)

# Gather all the NuSMV source files for proofs.
SMVs := $(shell find . -name '*.smv')

# The default target.
default : help
.PHONY : default

# XST doesn't care, but GHDL demands that an entity be compiled before it's referenced by another entity.
# Thus, define dependencies between entities here in order to guarantee proper compile order.
# It's not necessary to define the dependency between a .o file and *its own* .vhd file; that is autogenerated.
# It's also not necessary to define the dependency between a testbench file and its unit under test.
controller.o : madd.o rom.o types.o
rom.o : types.o
ssmultiplier.o : sumultiplier.o
xbee.o : byteshifter.o xbeereceiver.o xbeetransmitter.o
xbeereceiver.o : serialreceiver.o xbeebytereceiver.o xbeepacketreceiver.o
xbeetransmitter.o : serialtransmitter.o xbeebytetransmitter.o xbeepackettransmitter.o





##############################
# RULE FOR USAGE INFORMATION #
##############################

help :
	@echo "This is a multi-purpose Makefile which can do many things."
	@echo "To synthesize an Intel HEX file, run \"make synth\" or \"make synthesize\"."
	@echo "  (we expect to find the Xilinx settings32.sh file at $(XILINX_SETTINGS);"
	@echo "   if this path is wrong, please set the XILINX_SETTINGS environment variable"
	@echo "   to the correct path)"
	@echo "To run VHDL testbenches in GHDL, run \"make test\"."
	@echo "To run proofs of correctness in NuSMV, run \"make prove\"."
	@echo "To remove all autogenerated files, run \"make clean\"."
.PHONY : help





#######################
# RULES FOR SYNTHESIS #
#######################

# Targets to perform synthesis.
synth : synthesize
synthesize : $(PROJ).mcs
.PHONY : synth synthesize

# We can make a HEX file from a BIT file using Xilinx PROMGEN.
# Options:
#  -spi
#    Prevents reversing the bits in each byte (reversal is needed for parallel
#    Flash memories but not SPI memories).
#  -u 0 $(PROJ).bit
#    Inserts the BIT file into the generated image at address zero.
#  -p mcs
#    Generates an Intel HEX file.
#  -s 2048
#    Generates data for a 2MB (16Mb) Flash.
#  -w
#    Overwrites any existing file.
$(PROJ).mcs : $(PROJ).bit
	( source $(XILINX_SETTINGS) && promgen -spi -u 0 $(PROJ).bit -p mcs -s 2048 -w )

# We can make a BIT file from a routed NCD file using Xilinx BITGEN.
# Options
#  -d
#    Skips DRC, since it's done by MAP/PAR anyway.
#  -g Compress
#    Packs data more efficiently, resulting in a smaller bitstream, without
#    altering the semantics of the bitstream.
#  -g ConfigRate:1
#    Instructs the FPGA to clock in configuration data at 1Mbps.
#  -g GTS_cycle:3
#    Instructs the FPGA to release the GLOBAL 3-STATE net in completion cycle 3.
#  -g LCK_cycle:4
#    Instructs the FPGA to wait for digital clock managers to synchronize in
#    completion cycle 4.
#  -g GWE_cycle:5
#    Instructs the FPGA to release the GLOBAL WRITE-ENABLE net to allow the
#    application to run in completion cycle 5.
#  -g DONE_cycle:6
#    Instructs the FPGA to raise the DONE pin in completion cycle 6.
#  -g UnusedPin:PULLUP
#    Instructs the FPGA to put pullup resistors on I/O pins not used by the
#    application.
#  -w
#    Overwrites any existing file.
$(PROJ).bit : $(PROJ).ncd
	( source $(XILINX_SETTINGS) && bitgen -d -g Compress -g ConfigRate:1 -g GTS_cycle:3 -g LCK_cycle:4 -g GWE_cycle:5 -g DONE_cycle:6 -g UnusedPin:PULLUP $(PROJ).ncd $(PROJ).bit $(PROJ)_map.pcf -w )

# We can make a routed NCD file from an unrouted NCD file using Xilinx PAR.
# Options
#  -w
#    Overwrites any existing file.
$(PROJ).ncd : $(PROJ)_map.ncd
	( source $(XILINX_SETTINGS) && par $(PROJ)_map.ncd $(PROJ).ncd $(PROJ)_map.pcf -w )

# We can make an unrouted NCD file from an NGD file using Xilinx MAP.
# Options
#  -pr b
#    Uses flip-flops and latches built into the I/O pin drivers whenever
#    possible.
#  -w
#    Overwrites any existing file.
$(PROJ)_map.ncd : $(PROJ).ngd
	( source $(XILINX_SETTINGS) && map -pr b $(PROJ).ngd -o $(PROJ)_map.ncd -w )

# We can make an NGD file from an NGC file and a UCF file using Xilinx NGDBUILD.
$(PROJ).ngd : $(PROJ).ngc $(PROJ).ucf
	( source $(XILINX_SETTINGS) && ngdbuild $(PROJ).ngc )

# We can make an NCD file from an XST file, a PRJ file, and a bunch of VHD files
# using Xilinx XST.
$(PROJ).ngc : $(PROJ).xst $(PROJ).prj $(VHDs_common) $(VHDs_synth)
	( source $(XILINX_SETTINGS) && xst -ifn $(PROJ).xst )





################################
# RULES FOR SIMULATION TESTING #
################################

# Target to invoke all the individual test-running rules.
test : $(addprefix test-,$(SIM_TARGETS))
.PHONY : test

# Make a list of all the .o files corresponding to the .vhds.
SIM_OBJS := $(patsubst %.vhd,%.o,$(notdir $(VHDs_common) $(VHDs_sim)))

# Template of code to generate for each simulation target.
define sim_target_template

# Target to run this simulation target.
test-$(1) : $(1)
	./$(1)
.PHONY : test-$(1)

# Target to elaborate the final executable.
$(1) : $(SIM_OBJS)
	ghdl -e $(1)

endef

# Generate the per-simulation-target rules.
$(eval $(foreach target,$(SIM_TARGETS),$(call sim_target_template,$(target))))

# Template of code to analyze a VHD and generate an object file.
define sim_analyze_template

$(patsubst %.vhd,%.o,$(notdir $(1))) : $(1)
	ghdl -a --std=93 $(1)

endef

# Generate the per-VHD rules.
$(eval $(foreach vhd,$(VHDs_common) $(VHDs_sim),$(call sim_analyze_template,$(vhd))))

# Template of code to insert a dependency of a testbench on its unit under test.
define sim_test_uut_dep_template

$(1).o : $(patsubst %test,%,$(1)).o

endef

# Generate the dependencies of the testbenches on their units under test.
$(eval $(foreach target,$(SIM_TARGETS),$(call sim_test_uut_dep_template,$(target))))





#################################
# RULES FOR PROVING CORRECTNESS #
#################################

# Target to invoke all the individual proof-checking rules.
prove : $(addprefix prove-,$(notdir $(patsubst %.smv,%,$(SMVs))))
.PHONY : prove

# Template of code to generate for each proof file.
define prove_target_template

# Target to run this proof.
prove-$(notdir $(patsubst %.smv,%,$(1))) : $(1)
	NuSMV $(1)
.PHONY : prove-$(1)

endef

# Generate the per-proof-file rules.
$(eval $(foreach smv,$(SMVs),$(call prove_target_template,$(smv))))




#####################
# RULE FOR CLEANING #
#####################

clean :
	$(RM) *.bgn *.bit *.bld *.cfi *.drc *.lso *.lst *.map *.mcs *.mrp *.ncd *.ngc *.ngd *.ngm *.o *_pad.csv *_pad.txt *.pad *.par *.pcf *.prm *.ptwx *.srp *.unroutes *.xml *.xpi *.xrpt thunderbots_vhdl.prj work-obj93.cf $(SIM_TARGETS)
	$(RM) -r xlnx_auto_0_xdb xst
.PHONY : clean

