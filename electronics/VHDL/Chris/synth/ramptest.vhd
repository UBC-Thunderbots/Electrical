library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity RampTest is
	port(
		-- The 50MHz canned oscillator.
		Oscillator : in std_ulogic;

		-- Serial line to the XBee.
		XBeeRX : in std_ulogic;
		XBeeTX : out std_ulogic;

		-- SPI lines to and from the PIC.
		AppSS : in std_ulogic;
		AppOut : out std_ulogic;
		AppIn : in std_ulogic;
		AppClk : in std_ulogic;

		-- Control lines to and from the motor controllers.
		BrakeDrive : out std_ulogic;
		BrakeDribbler : out std_ulogic;
		PWM1 : out std_ulogic;
		PWM2 : out std_ulogic;
		PWM3 : out std_ulogic;
		PWM4 : out std_ulogic;
		PWMD : out std_ulogic;
		Dir1 : out std_ulogic;
		Dir2 : out std_ulogic;
		Dir3 : out std_ulogic;
		Dir4 : out std_ulogic;
		DirD : out std_ulogic;
		Fault1 : in std_ulogic;
		Fault2 : in std_ulogic;
		Fault3 : in std_ulogic;
		Fault4 : in std_ulogic;
		FaultD : in std_ulogic;
		DSense : in std_ulogic;

		-- Optical encoder phase lines.
		Encoder1A : in std_ulogic;
		Encoder1B : in std_ulogic;
		Encoder2A : in std_ulogic;
		Encoder2B : in std_ulogic;
		Encoder3A : in std_ulogic;
		Encoder3B : in std_ulogic;
		Encoder4A : in std_ulogic;
		Encoder4B : in std_ulogic
	);
end entity RampTest;

architecture Behavioural of RampTest is
	-- The address of the host XBee.
	constant HostAddress : unsigned(63 downto 0) := X"0013a2004053a24c";

	-- Whether to write the PWM values or the encoder readings.
	constant WritePWMs : boolean := false;

	-- The state machine.
	type StateType is (Init, Run, RecordingDone, SendSOP, SendLengthMSB, SendLengthLSB, SendAPIID, SendFrameID, SendAddress, SendOptions, SendRAMAddressMSB, SendRAMAddressLSB, LoadData, SendDataMSB, SendDataLSB, SendChecksum, Sleep);
	signal State : StateType := Init;
	subtype PIDTicksType is natural range 0 to 4999;
	signal PIDTicks : PIDTicksType := 0;
	subtype StateTicksType is natural range 0 to 1023;
	signal StateTicks : StateTicksType := 0;
	signal WriteNextCycle : boolean := false;

	-- The serial transmitter stuff.
	signal Checksum : unsigned(7 downto 0);
	signal SerialData : std_ulogic_vector(7 downto 0);
	signal SerialLoad : std_ulogic;
	signal SerialBusy : std_ulogic;
	signal XBeeData : std_ulogic_vector(7 downto 0);
	signal XBeeLoad : std_ulogic;
	signal XBeeSOP : std_ulogic;
	signal XBeeBusy : std_ulogic;
	signal DataCounter : natural range 0 to 49;

	-- The LFSR stuff.
	signal LFSREnable : std_ulogic := '0';
	signal LFSROut : std_ulogic;

	-- The RAMs.
	type RAMType is array(0 to 1023) of signed(15 downto 0);
	signal RAM : RAMType;
	signal RAMIndex : natural range 0 to 1023 := 0;
	signal RAMWrite : boolean := false;
	signal RAMClearIndex : boolean := false;
	signal RAMIncrementIndex : boolean := false;
	signal RAMRData : signed(15 downto 0) := to_signed(0, 16);
	signal RAMWData : signed(15 downto 0) := to_signed(0, 16);

	-- The clocks generated by the DCM from Oscillator.
	signal Clock1 : std_ulogic;
	signal Clock10 : std_ulogic;
	signal Clock100 : std_ulogic;

	-- Latched versions of all input pins other than Oscillator.
	signal Encoder4AL : std_ulogic := '0';
	signal Encoder4BL : std_ulogic := '0';

	-- Encoder counts from the Gray counter.
	signal Encoder4Count : signed(10 downto 0);
	signal EncoderReset : std_ulogic;

	-- PWM values.
	signal Speed4 : signed(10 downto 0);
	signal Direction4 : std_ulogic;
	signal DutyCycle4 : unsigned(9 downto 0);
begin
	-- Constant pins.
	AppOut <= '0';
	BrakeDrive <= '0' when State = Init or State = Run else '1';
	BrakeDribbler <= '0';
	PWM1 <= '1';
	PWM2 <= '1';
	PWM3 <= '1';
	PWMD <= '1';
	Dir1 <= '0';
	Dir2 <= '0';
	Dir3 <= '0';
	Dir4 <= 'Z' when Direction4 = '1' else '0';
	DirD <= '0';

	-- Pass the Oscillator pin through a DCM to get the final clocks.
	ClockGenInstance : entity work.ClockGen(Behavioural)
	port map(
		Oscillator => Oscillator,
		Clock100 => Clock100,
		Clock10 => Clock10,
		Clock1 => Clock1
	);

	-- Latch the inputs into the local signals.
	process(Clock1)
	begin
		if rising_edge(Clock1) then
			Encoder4AL <= Encoder4A;
			Encoder4BL <= Encoder4B;
		end if;
	end process;

	-- Wheel stuff.
	GrayCounterInstance4 : entity work.GrayCounter(Behavioural)
	generic map(
		Width => 11,
		Sign => -1
	)
	port map(
		Clock1 => Clock1,
		A => Encoder4AL,
		B => Encoder4BL,
		Reset => EncoderReset,
		Count => Encoder4Count
	);
	SignMagnitude4Instance : entity work.SignMagnitude(Behavioural)
	generic map(
		Width => 11
	)
	port map(
		Value => Speed4,
		Absolute => DutyCycle4,
		Sign => Direction4
	);
	PWM4Instance : entity work.PWM(Behavioural)
	generic map(
		Width => 10,
		Modulus => 1023,
		Invert => true
	)
	port map(
		Clock100 => Clock100,
		DutyCycle => DutyCycle4,
		PWM => PWM4
	);

	-- The XBee transmitter stuff.
	XBeeByteTransmitterInstance : entity work.XBeeByteTransmitter(Behavioural)
	port map(
		Clock1 => Clock1,
		Data => XBeeData,
		Load => XBeeLoad,
		SOP => XBeeSOP,
		Busy => XBeeBusy,
		SerialData => SerialData,
		SerialLoad => SerialLoad,
		SerialBusy => SerialBusy
	);
	SerialTransmitterInstance : entity work.SerialTransmitter(Behavioural)
	port map(
		Clock1 => Clock1,
		Data => SerialData,
		Load => SerialLoad,
		Busy => SerialBusy,
		Serial => XBeeTX
	);

	-- The state machine.
	process(Clock1)
		variable ResetChecksum : boolean;
		variable DeltaChecksum : unsigned(7 downto 0);
		variable IncrementPIDTicks : boolean;
		variable IncrementStateTicks : boolean;
		variable ResetStateTicks : boolean;
	begin
		if rising_edge(Clock1) then
			EncoderReset <= '0';
			ResetChecksum := false;
			DeltaChecksum := X"00";
			IncrementPIDTicks := false;
			IncrementStateTicks := false;
			ResetStateTicks := false;
			RAMWrite <= false;
			RAMClearIndex <= false;
			RAMIncrementIndex <= false;
			XBeeLoad <= '0';
			XBeeSOP <= '0';
			LFSREnable <= '0';
			if State = Init then
				Speed4 <= to_signed(0, Speed4'length);
				RAMClearIndex <= true;
				EncoderReset <= '1';
				if PIDTicks = PIDTicksType'high then
					if StateTicks = StateTicksType'high then
						State <= Run;
					end if;
					IncrementStateTicks := true;
				end if;
				IncrementPIDTicks := true;
			elsif State = Run then
				if PIDTicks = PIDTicksType'high then
					if StateTicks = 199 then
						if Speed4 = to_signed(1023, Speed4'length) then
							State <= RecordingDone;
						else
							Speed4 <= Speed4 + 1;
						end if;
						ResetStateTicks := true;
						WriteNextCycle <= true;
					else
						IncrementStateTicks := true;
						EncoderReset <= '1';
					end if;
					LFSREnable <= '1';
				end if;
				IncrementPIDTicks := true;
				if WriteNextCycle then
					WriteNextCycle <= false;
					RAMWrite <= true;
					RAMIncrementIndex <= true;
					RAMWData <= resize(Encoder4Count, RAMWData'length);
					EncoderReset <= '1';
				end if;
			elsif XBeeBusy = '0' then
				if State = RecordingDone then
					RAMClearIndex <= true;
					State <= SendSOP;
				elsif State = SendSOP then
					XBeeSOP <= '1';
					State <= SendLengthMSB;
				elsif State = SendLengthMSB then
					XBeeData <= X"00";
					XBeeLoad <= '1';
					State <= SendLengthLSB;
				elsif State = SendLengthLSB then
					XBeeData <= X"6D";
					XBeeLoad <= '1';
					State <= SendAPIID;
					ResetChecksum := true;
				elsif State = SendAPIID then
					XBeeData <= X"00";
					DeltaChecksum := X"00";
					XBeeLoad <= '1';
					State <= SendFrameID;
				elsif State = SendFrameID then
					XBeeData <= X"01";
					DeltaChecksum := X"01";
					XBeeLoad <= '1';
					State <= SendAddress;
					DataCounter <= 7;
				elsif State = SendAddress then
					XBeeData <= std_ulogic_vector(HostAddress((DataCounter + 1) * 8 - 1 downto DataCounter * 8));
					DeltaChecksum := HostAddress((DataCounter + 1) * 8 - 1 downto DataCounter * 8);
					XBeeLoad <= '1';
					if DataCounter = 0 then
						State <= SendOptions;
					end if;
					DataCounter <= DataCounter - 1;
				elsif State = SendOptions then
					XBeeData <= X"00";
					DeltaChecksum := X"00";
					XBeeLoad <= '1';
					State <= SendRAMAddressMSB;
				elsif State = SendRAMAddressMSB then
					XBeeData <= std_ulogic_vector(to_unsigned(RAMIndex / 256, 8));
					DeltaChecksum := to_unsigned(RAMIndex / 256, 8);
					XBeeLoad <= '1';
					State <= SendRAMAddressLSB;
				elsif State = SendRAMAddressLSB then
					XBeeData <= std_ulogic_vector(to_unsigned(RAMIndex mod 256, 8));
					DeltaChecksum := to_unsigned(RAMIndex mod 256, 8);
					XBeeLoad <= '1';
					State <= LoadData;
					DataCounter <= 47;
				elsif State = LoadData then
					State <= SendDataMSB;
				elsif State = SendDataMSB then
					XBeeData <= std_ulogic_vector(RAMRData(15 downto 8));
					DeltaChecksum := unsigned(std_ulogic_vector(RAMRData(15 downto 8)));
					XBeeLoad <= '1';
					State <= SendDataLSB;
				elsif State = SendDataLSB then
					XBeeData <= std_ulogic_vector(RAMRData(7 downto 0));
					DeltaChecksum := unsigned(std_ulogic_vector(RAMRData(7 downto 0)));
					XBeeLoad <= '1';
					RAMIncrementIndex <= true;
					if DataCounter = 0 then
						State <= SendChecksum;
					else
						State <= LoadData;
					end if;
					DataCounter <= DataCounter - 1;
				elsif State = SendChecksum then
					XBeeData <= std_ulogic_vector(Checksum);
					XBeeLoad <= '1';
					State <= Sleep;
				elsif State = Sleep then
					if PIDTicks = PIDTicksType'high then
						if StateTicks = 25 then
							State <= SendSOP;
							ResetStateTicks := true;
						else
							IncrementStateTicks := true;
						end if;
					end if;
					IncrementPIDTicks := true;
				end if;
			end if;
			if ResetChecksum then
				Checksum <= X"FF";
			else
				Checksum <= Checksum - DeltaChecksum;
			end if;
			if IncrementPIDTicks then
				PIDTicks <= (PIDTicks + 1) mod (PIDTicksType'high + 1);
			end if;
			if ResetStateTicks then
				StateTicks <= 0;
			elsif IncrementStateTicks then
				StateTicks <= (StateTicks + 1) mod (StateTicksType'high + 1);
			end if;
		end if;
	end process;

	process(Clock1)
	begin
		if rising_edge(Clock1) then
			if RAMWrite then
				RAM(RAMIndex) <= RAMWData;
			end if;
			RAMRData <= RAM(RAMIndex);
			if RAMClearIndex then
				RAMIndex <= 0;
			elsif RAMIncrementIndex then
				RAMIndex <= (RAMIndex + 1) mod 1024;
			end if;
		end if;
	end process;
end architecture Behavioural;
