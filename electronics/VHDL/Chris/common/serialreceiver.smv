MODULE main

VAR
	Din : boolean;
VAR
	Dgood : boolean;
	Ferr : boolean;
	Dbuf : word[9];
	BitClocks : 0..39;
	BitValue : -16..16;

ASSIGN
	init(Dgood) := 0;
	init(Ferr) := 0;
	init(Dbuf) := 0b9_000000000;
	init(BitClocks) := 39;
	init(BitValue) := 0;


	next(Dgood) :=
		case
			bool(Dbuf[0:0]) & (BitClocks = 0) & !bool(Dbuf[1:1]) & !Ferr & BitValue >= 4 : 1;
			1 : 0;
		esac;

	next(Ferr) :=
		case
			!bool(Dbuf[0:0]) & !Din : 0;
			bool(Dbuf[0:0]) & (BitClocks = 0) & !(BitValue >= 4 | BitValue <= -4) : 1;
			bool(Dbuf[0:0]) & (BitClocks = 0) & !bool(Dbuf[1:1]) & !(!Ferr & BitValue >= 4) : 1;
			1 : Ferr;
		esac;

	next(Dbuf) :=
		case
			!bool(Dbuf[0:0]) :
				case
					!Din : 0b9_111111111;
					1 : Dbuf;
				esac;
			1 :
				case
					BitClocks = 0 :
						case
							Dbuf = 0b9_111111111 & BitValue > -4 : 0b9_000000000;
							BitValue >= 4 : 0b1_1 :: Dbuf[8:1];
							BitValue <= -4 : 0b1_0 :: Dbuf[8:1];
							1 : 0b1_1 :: Dbuf[8:1];
						esac;
					1 : Dbuf;
				esac;
		esac;

	next(BitClocks) :=
		case
			!bool(Dbuf[0:0]) :
				39;
			1 :
				case
					BitClocks > 0 : BitClocks - 1;
					1 : 39;
				esac;
		esac;

	next(BitValue) :=
		case
			!bool(Dbuf[0:0]) :
				0;
			1 :
				case
					BitClocks > 27 :
						BitValue;
					BitClocks > 12 :
						case
							-- These lines are required to allow us to use an integer-based type
							-- instead of having to go for the word-based type. This makes the
							-- syntax more pleasant, but we do have to make it obvious to NuSMV
							-- that we can't ever go outside the defined range of values. We do
							-- this by defining the data type to accept -16..16 and, right here,
							-- doing saturated arithmetic. This means that the semantics of this
							-- code is very slightly different than the semantics of the original
							-- VHDL. We prove that this difference is irrelevant by means of the
							-- INVARSPEC BitValue <= 15 & BitValue >= -15; line below.
							BitValue = 16 : 16;
							BitValue = -16 : -16;
							Din : BitValue + 1 ;
							1 : BitValue - 1;
						esac;
					BitClocks > 0 :
						BitValue;
					1 :
						0;
				esac;
		esac;

--
-- IDENTITY FOR CTL SPECIFICATIONS
--
-- A[x W y] = !E[!y U (!x & !y)]
--

-- Should not overflow the bit value counter.
INVARSPEC BitValue <= 15 & BitValue >= -15;

-- Should never have a framing error and good data simultaneously.
INVARSPEC !(Ferr & Dgood);

-- If good data is found, byte should be framed right (start bit).
INVARSPEC Dgood -> !bool(Dbuf[0:0]);

-- Dgood should never stay high for more than one clock cycle.
CTLSPEC AG (Dgood -> AX !Dgood);

-- If you see a framing error, Ferr should stay true until the system goes idle.
-- CTLSPEC AG (Ferr -> A [Ferr W !bool(Dbuf[0:0])]);
CTLSPEC AG (Ferr -> !E [bool(Dbuf[0:0]) U (!Ferr & bool(Dbuf[0:0]))]);

-- No matter what happens, you can get back to an idle state.
CTLSPEC AG EF !bool(Dbuf[0:0]);

-- All errors are transient (if you wait long enough, you can start receiving again).
CTLSPEC AG EF Dgood;

-- There is a path where you do sometime receive some data, but never see a framing
-- error (i.e. the receiver is capable of properly interpreting a perfect bitstream).
-- You can follow this path from any idle state.
CTLSPEC AG((!bool(Dbuf[0:0]) & !Ferr) -> E [!Ferr U (Dgood & !Ferr)]);
