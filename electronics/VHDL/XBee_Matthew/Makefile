# The name of the project.
PROJ := thunderbots

# The names of all the top-level test targets.
SIM_TARGETS := txpacketassemblertest

# Gather all the VHDL source files in the three directories.
VHDs_common := $(shell find common -name .svn -prune -o -name '*.vhd' -print)
VHDs_sim    := $(shell find sim    -name .svn -prune -o -name '*.vhd' -print)
VHDs_synth  := $(shell find synth  -name .svn -prune -o -name '*.vhd' -print)

# Gather all the NuSMV source files for proofs.
SMVs := $(shell find . -name '*.smv')





##############################
# RULE FOR USAGE INFORMATION #
##############################

help :
	@echo 'This is a multi-purpose Makefile which can do many things.'
	@echo 'To synthesize an Intel HEX file, run "make synth" or "make synthesize".'
	@echo '  (remember to source settings32.sh from the Xilinx install first)'
	@echo 'To run VHDL testbenches in GHDL, run "make test".'
	@echo 'To run proofs of correctness in NuSMV, run "make prove".'
	@echo 'To remove all autogenerated files, run "make clean".'
.PHONY : help





#######################
# RULES FOR SYNTHESIS #
#######################

# Targets to perform synthesis.
synth : synthesize
synthesize : $(PROJ).mcs
.PHONY : synth synthesize

# We can make a HEX file from a BIT file using Xilinx PROMGEN.
# Options:
#  -spi
#    Prevents reversing the bits in each byte (reversal is needed for parallel
#    Flash memories but not SPI memories).
#  -u 0 $(PROJ).bit
#    Inserts the BIT file into the generated image at address zero.
#  -p mcs
#    Generates an Intel HEX file.
#  -s 2048
#    Generates data for a 2MB (16Mb) Flash.
#  -w
#    Overwrites any existing file.
$(PROJ).mcs : $(PROJ).bit
	promgen -spi -u 0 $(PROJ).bit -p mcs -s 2048 -w

# We can make a BIT file from a routed NCD file using Xilinx BITGEN.
# Options
#  -d
#    Skips DRC, since it's done by MAP/PAR anyway.
#  -g Compress
#    Packs data more efficiently, resulting in a smaller bitstream, without
#    altering the semantics of the bitstream.
#  -g ConfigRate:1
#    Instructs the FPGA to clock in configuration data at 1Mbps.
#  -g GTS_cycle:3
#    Instructs the FPGA to release the GLOBAL 3-STATE net in completion cycle 3.
#  -g LCK_cycle:4
#    Instructs the FPGA to wait for digital clock managers to synchronize in
#    completion cycle 4.
#  -g GWE_cycle:5
#    Instructs the FPGA to release the GLOBAL WRITE-ENABLE net to allow the
#    application to run in completion cycle 5.
#  -g DONE_cycle:6
#    Instructs the FPGA to raise the DONE pin in completion cycle 6.
#  -g UnusedPin:PULLUP
#    Instructs the FPGA to put pullup resistors on I/O pins not used by the
#    application.
#  -w
#    Overwrites any existing file.
$(PROJ).bit : $(PROJ).ncd
	bitgen -d -g Compress -g ConfigRate:1 -g GTS_cycle:3 -g LCK_cycle:4 -g GWE_cycle:5 -g DONE_cycle:6 -g UnusedPin:PULLUP $(PROJ).ncd $(PROJ).bit $(PROJ)_map.pcf -w

# We can make a routed NCD file from an unrouted NCD file using Xilinx PAR.
# Options
#  -w
#    Overwrites any existing file.
$(PROJ).ncd : $(PROJ)_map.ncd
	par $(PROJ)_map.ncd $(PROJ).ncd $(PROJ)_map.pcf -w

# We can make an unrouted NCD file from an NGD file using Xilinx MAP.
# Options
#  -pr b
#    Uses flip-flops and latches built into the I/O pin drivers whenever
#    possible.
#  -w
#    Overwrites any existing file.
$(PROJ)_map.ncd : $(PROJ).ngd
	map -pr b $(PROJ).ngd -o $(PROJ)_map.ncd -w

# We can make an NGD file from an NGC file and a UCF file using Xilinx NGDBUILD.
$(PROJ).ngd : $(PROJ).ngc $(PROJ).ucf
	ngdbuild $(PROJ).ngc

# We can make an NCD file from an XST file, a PRJ file, and a bunch of VHD files
# using Xilinx XST.
$(PROJ).ngc : $(PROJ).xst $(PROJ).prj $(VHDs_common) $(VHDs_synth)
	xst -ifn $(PROJ).xst





################################
# RULES FOR SIMULATION TESTING #
################################

# Target to invoke all the individual test-running rules.
test : $(addprefix test-,$(SIM_TARGETS))
.PHONY : test

# Make a list of all the .o files corresponding to the .vhds.
SIM_OBJS := $(patsubst %.vhd,%.o,$(notdir $(VHDs_common) $(VHDs_sim)))

# Template of code to generate for each simulation target.
define sim_target_template

# Target to run this simulation target.
test-$(1) : $(1)
	./$(1)
.PHONY : test-$(1)

# Target to elaborate the final executable.
$(1) : $(SIM_OBJS)
	ghdl -e $(1)

endef

# Generate the per-simulation-target rules.
$(eval $(foreach target,$(SIM_TARGETS),$(call sim_target_template,$(target))))

# Template of code to analyze a VHD and generate an object file.
#$$(shell echo $(patsubst %.vhd,%.o,$(notdir $(1))) : $(1))
define sim_analyze_template

$(patsubst %.vhd,%.o,$(notdir $(1))) : $(1)
	ghdl -a --std=93 $(1)

endef

# Generate the per-VHD rules.
$(eval $(foreach vhd,$(VHDs_common) $(VHDs_sim),$(call sim_analyze_template,$(vhd))))





#################################
# RULES FOR PROVING CORRECTNESS #
#################################

# Target to invoke all the individual proof-checking rules.
prove : $(addprefix prove-,$(notdir $(patsubst %.smv,%,$(SMVs))))
.PHONY : prove

# Template of code to generate for each proof file.
define prove_target_template

# Target to run this proof.
prove-$(notdir $(patsubst %.smv,%,$(1))) : $(1)
	NuSMV $(1)
.PHONY : prove-$(1)

endef

# Generate the per-proof-file rules.
$(eval $(foreach smv,$(SMVs),$(call prove_target_template,$(smv))))




#####################
# RULE FOR CLEANING #
#####################

clean :
	$(RM) *.bgn *.bit *.bld *.cfi *.drc *.lso *.lst *.map *.mcs *.mrp *.ncd *.ngc *.ngd *.ngm *.o *_pad.csv *_pad.txt *.pad *.par *.pcf *.prm *.ptwx *.srp *.unroutes *.xml *.xpi *.xrpt work-obj93.cf $(SIM_TARGETS)
	$(RM) -r xlnx_auto_0_xdb xst
.PHONY : clean

