# The name of the project.
PROJ := thunderbots

# The shell to use to run commands.
override SHELL := /bin/bash

# The names of all the top-level test targets.
SIM_TARGETS := boostcontrollertest deadbandtest crc16test flashchecksummertest

# The path to the Xilinx settings32.sh file.
XILINX_SETTINGS ?= /opt/xilinx/settings32.sh

# Gather all the VHDL source files in the three directories.
Vs_common := $(shell find common -name .svn -prune -o -name '*.v' -print)
VHDs_common := $(shell find common -name .svn -prune -o -name '*.vhd' -print)
VHDs_sim    := $(shell find sim    -name .svn -prune -o -name '*.vhd' -print)
VHDs_synth  := $(shell find synth  -name .svn -prune -o -name '*.vhd' -print)

# Gather all the NuSMV source files for proofs.
SMVs := $(shell find . -name '*.smv')

# The default target.
default : help
.PHONY : default

# XST doesn't care, but GHDL demands that an entity be compiled before it's referenced by another entity.
# Thus, define dependencies between entities here in order to guarantee proper compile order.
# It's not necessary to define the dependency between a .o file and *its own* .vhd file; that is autogenerated.
ghdl/obj/adc.o : ghdl/obj/types.o
ghdl/obj/boostcontroller.o : ghdl/obj/clock.o ghdl/obj/types.o
ghdl/obj/boostcontrollertest.o : ghdl/obj/boostcontroller.o ghdl/obj/clock.o ghdl/obj/types.o
ghdl/obj/commutator.o : ghdl/obj/types.o
ghdl/obj/crc16.o :
ghdl/obj/crc16test.o : ghdl/obj/crc16.o
ghdl/obj/deadband.o : ghdl/obj/types.o
ghdl/obj/deadbandtest.o : ghdl/obj/deadband.o ghdl/obj/types.o
ghdl/obj/flashchecksummer.o : ghdl/obj/clock.o ghdl/obj/crc16.o
ghdl/obj/flashchecksummertest.o : ghdl/obj/clock.o ghdl/obj/flashchecksummer.o
ghdl/obj/graycounter.o : ghdl/obj/types.o
ghdl/obj/kicker.o : ghdl/obj/syncdown.o ghdl/obj/types.o
ghdl/obj/main.o : ghdl/obj/adc.o ghdl/obj/boostcontroller.o ghdl/obj/kicker.o ghdl/obj/graycounter.o ghdl/obj/motor.o ghdl/obj/parbus.o ghdl/obj/types.o
ghdl/obj/motor.o : ghdl/obj/clock.o ghdl/obj/commutator.o ghdl/obj/deadband.o ghdl/obj/pwm.o ghdl/obj/types.o
ghdl/obj/parbus.o : ghdl/obj/types.o
ghdl/obj/pwm.o :
ghdl/obj/syncdown.o :
ghdl/obj/types.o :





##############################
# RULE FOR USAGE INFORMATION #
##############################

help :
	@echo "This is a multi-purpose Makefile which can do many things."
	@echo "To synthesize an Intel HEX file, run \"make synth\" or \"make synthesize\"."
	@echo "  (we expect to find the Xilinx settings32.sh file at $(XILINX_SETTINGS);"
	@echo "   if this path is wrong, please set the XILINX_SETTINGS environment variable"
	@echo "   to the correct path)"
	@echo "To just run the synthesis phase but not the mapper or anything after, run"
	@echo "  \"make xst\"."
	@echo "To run up to the mapper but not P&R or anything after, run \"make map\"."
	@echo "To run VHDL testbenches in GHDL, run \"make test\"."
	@echo "To run proofs of correctness in NuSMV, run \"make prove\"."
	@echo "To generate HTML documentation, run \"make doc\"."
	@echo "To remove all autogenerated files, run \"make clean\"."
.PHONY : help





##############################################
# RULE FOR GENERATING THE HTML DOCUMENTATION #
##############################################
doc :
	doxygen
.PHONY : doc





#######################
# RULES FOR SYNTHESIS #
#######################

# Targets to perform synthesis.
synth : synthesize
synthesize : $(PROJ).mcs
xst : $(PROJ).ngc
map : $(PROJ)_map.ncd
.PHONY : synth synthesize xst map

# We can make a HEX file from a BIT file using Xilinx PROMGEN.
# Options:
#  -spi
#    Prevents reversing the bits in each byte (reversal is needed for parallel
#    Flash memories but not SPI memories).
#  -u 0 $(PROJ).bit
#    Inserts the BIT file into the generated image at address zero.
#  -p mcs
#    Generates an Intel HEX file.
#  -s 2048
#    Generates data for a 2MB (16Mb) Flash.
#  -w
#    Overwrites any existing file.
$(PROJ).mcs : $(PROJ).bit
	( source $(XILINX_SETTINGS) && promgen -spi -u 0 $(PROJ).bit -p mcs -s 2048 -w )

# We can make a BIT file from a routed NCD file using Xilinx BITGEN.
# Options
#  -bd ../firmware/main/main.elf
#    Loads the firmware from the ELF file into the block RAMs.
#  -d
#    Skips DRC, since it's done by MAP/PAR anyway.
#  -g Compress
#    Packs data more efficiently, resulting in a smaller bitstream, without
#    altering the semantics of the bitstream.
#  -g ConfigRate:10
#    Instructs the FPGA to clock in configuration data at 10 Mbps.
#  -g DriveDone:1
#    Instructs the FPGA to drive the DONE pin high hard instead of leaving it to
#    float with a pull-up.
#  -g GTS_cycle:3
#    Instructs the FPGA to release the GLOBAL 3-STATE net in completion cycle 3.
#  -g LCK_cycle:4
#    Instructs the FPGA to wait for digital clock managers to synchronize in
#    completion cycle 4.
#  -g GWE_cycle:5
#    Instructs the FPGA to release the GLOBAL WRITE-ENABLE net to allow the
#    application to run in completion cycle 5.
#  -g DONE_cycle:6
#    Instructs the FPGA to raise the DONE pin in completion cycle 6.
#  -g UnusedPin:PULLUP
#    Instructs the FPGA to put pullup resistors on I/O pins not used by the
#    application.
#  -w
#    Overwrites any existing file.
$(PROJ).bit : $(PROJ).ncd ../firmware/main/main.elf
	( source $(XILINX_SETTINGS) && bitgen -bd ../firmware/main/main.elf -d -g Compress -g ConfigRate:10 -g DriveDone:yes -g GTS_cycle:3 -g LCK_cycle:4 -g GWE_cycle:5 -g DONE_cycle:6 -g UnusedPin:PULLUP $(PROJ).ncd $(PROJ).bit $(PROJ)_map.pcf -w )

# The ELF file depends on all its source and header files and the Makefile and linker script.
# It can be rebuilt by recursively making in the firmware/main directory.
../firmware/main/main.elf : $(wildcard ../firmware/main/*.c) $(wildcard ../firmware/main/*.h) ../firmware/main/Makefile ../firmware/main/navre.ld
	$(MAKE) -C ../firmware/main

# We can make a routed NCD file from an unrouted NCD file using Xilinx PAR.
# Options
#  -w
#    Overwrites any existing file.
$(PROJ).ncd : $(PROJ)_map.ncd
	( source $(XILINX_SETTINGS) && par $(PROJ)_map.ncd $(PROJ).ncd $(PROJ)_map.pcf -w )

# We can make an unrouted NCD file from an NGD file using Xilinx MAP.
# Options
#  -pr b
#    Uses flip-flops and latches built into the I/O pin drivers whenever
#    possible.
#  -w
#    Overwrites any existing file.
#  -detail
#    Generates a more detailed report file.
$(PROJ)_map.ncd : $(PROJ).ngd
	( source $(XILINX_SETTINGS) && map -pr b $(PROJ).ngd -o $(PROJ)_map.ncd -w -detail )

# We can make an NGD file from an NGC file and a UCF file using Xilinx NGDBUILD.
$(PROJ).ngd : $(PROJ).ngc $(PROJ).ucf $(PROJ).bmm
	( source $(XILINX_SETTINGS) && ngdbuild -bm $(PROJ).bmm $(PROJ).ngc )

# We can make an NCD file from an XST file, a PRJ file, and a bunch of VHD files
# using Xilinx XST.
$(PROJ).ngc : $(PROJ).xst $(PROJ).prj $(Vs_common) $(VHDs_common) $(VHDs_synth)
	( source $(XILINX_SETTINGS) && xst -ifn $(PROJ).xst )





################################
# RULES FOR SIMULATION TESTING #
################################

# Target to invoke all the individual test-running rules.
test : $(addprefix test-,$(SIM_TARGETS))
.PHONY : test

# Make a list of all the .o files corresponding to the .vhds.
SIM_OBJS := $(patsubst %.vhd,ghdl/obj/%.o,$(notdir $(VHDs_common) $(VHDs_sim)))

# Template of code to generate for each simulation target.
define sim_target_template

# Target to run this simulation target.
test-$(1) : ghdl/bin/$(1)
	@mkdir -p ghdl/bin
	ghdl/bin/$(1)
.PHONY : test-$(1)

# Target to elaborate the final executable.
ghdl/bin/$(1) : ghdl/obj/$(1).o
	@mkdir -p ghdl/bin
	cd ghdl/bin && ghdl -e --workdir=../obj $(1)

endef

# Generate the per-simulation-target rules.
$(eval $(foreach target,$(SIM_TARGETS),$(call sim_target_template,$(target))))

# Template of code to analyze a VHD and generate an object file.
define sim_analyze_template

$(patsubst %.vhd,ghdl/obj/%.o,$(notdir $(1))) : $(1)
	@mkdir -p ghdl/obj
	ghdl -a --std=93 --workdir=ghdl/obj $(1)

endef

# Generate the per-VHD rules.
$(eval $(foreach vhd,$(VHDs_common) $(VHDs_sim),$(call sim_analyze_template,$(vhd))))





#################################
# RULES FOR PROVING CORRECTNESS #
#################################

# Target to invoke all the individual proof-checking rules.
prove : $(addprefix prove-,$(notdir $(patsubst %.smv,%,$(SMVs))))
.PHONY : prove

# Template of code to generate for each proof file.
define prove_target_template

# Target to run this proof.
prove-$(notdir $(patsubst %.smv,%,$(1))) : $(1)
	NuSMV $(1)
.PHONY : prove-$(1)

endef

# Generate the per-proof-file rules.
$(eval $(foreach smv,$(SMVs),$(call prove_target_template,$(smv))))




#####################
# RULE FOR CLEANING #
#####################

clean :
	$(RM) *.bgn *.bit *.bld *.cfi *.drc *.html *.log *.lso *.lst *.map *.mcs *.mrp *.ncd *.ngc *.ngd *.ngm *_pad.csv *_pad.txt *.pad *.par *.pcf *.prm *.ptwx *.srp *.unroutes *.xml *.xpi *.xrpt $(PROJ)_bd.bmm $(PROJ)_bitgen.xwbt $(PROJ)_vhdl.prj work-obj93.cf
	$(RM) -r ghdl html xlnx_auto_0_xdb xst _xmsgs
.PHONY : clean

