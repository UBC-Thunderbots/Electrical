# The name of the project.
PROJ := thunderbots

# The shell to use to run commands.
override SHELL := /bin/bash

# The names of all the top-level test targets.
SIM_TARGETS := crc_step_test spi_slave_test

# The path to the Xilinx settings32.sh file.
XILINX_SETTINGS ?= /opt/xilinx/settings32.sh

# The number of processors in the machine.
ifeq ($(origin PROCESSORS), undefined)
PROCESSORS := $(shell ./get_processors.sh)
endif

# Gather all the VHDL source files in the three directories.
Vs_common := $(shell find common -name .svn -prune -o -name '*.v' -print)
VHDs_common := $(shell find common -name .svn -prune -o -name '*.vhd' -print)
VHDs_sim    := $(shell find sim    -name .svn -prune -o -name '*.vhd' -print)
VHDs_synth  := $(shell find synth  -name .svn -prune -o -name '*.vhd' -print)

# Gather all the NuSMV source files for proofs.
SMVs := $(shell find . -name '*.smv')

# The default target.
default : help
.PHONY : default

# XST doesn't care, but GHDL demands that an entity be compiled before it's referenced by another entity.
# Thus, define dependencies between entities here in order to guarantee proper compile order.
# It's not necessary to define the dependency between a .o file and *its own* .vhd file; that is autogenerated.
# Files in common first, then files in sim.
ghdl/obj/accelerometer.o : ghdl/obj/imu_low_level.o ghdl/obj/readable_register.o ghdl/obj/types.o
ghdl/obj/arbiter.o : ghdl/obj/types.o
ghdl/obj/clock.o :
ghdl/obj/gyro.o : ghdl/obj/imu_low_level.o ghdl/obj/readable_register.o ghdl/obj/types.o
ghdl/obj/imu_low_level.o : ghdl/obj/spi_master.o ghdl/obj/types.o
ghdl/obj/interrupt_controller.o : ghdl/obj/commands.o ghdl/obj/types.o
ghdl/obj/majority.o :
ghdl/obj/mrf.o : ghdl/obj/arbiter.o ghdl/obj/mrf_common.o ghdl/obj/mrf_direct_access.o ghdl/obj/mrf_interrupt.o ghdl/obj/mrf_low_level.o ghdl/obj/mrf_receive.o ghdl/obj/mrf_transmit.o ghdl/obj/types.o
ghdl/obj/mrf_common.o :
ghdl/obj/mrf_crc.o :
ghdl/obj/mrf_direct_access.o : ghdl/obj/commands.o ghdl/obj/mrf_common.o ghdl/obj/types.o
ghdl/obj/mrf_interrupt.o : ghdl/obj/commands.o ghdl/obj/mrf_common.o ghdl/obj/types.o
ghdl/obj/mrf_low_level.o : ghdl/obj/mrf_common.o ghdl/obj/spi_master.o ghdl/obj/types.o
ghdl/obj/mrf_receive.o : ghdl/obj/commands.o ghdl/obj/mrf_common.o ghdl/obj/mrf_crc.o ghdl/obj/types.o
ghdl/obj/mrf_transmit.o : ghdl/obj/commands.o ghdl/obj/mrf_common.o ghdl/obj/types.o
ghdl/obj/motor.o : ghdl/obj/motor_common.o ghdl/obj/motor_commutator.o ghdl/obj/motor_hall_speed.o ghdl/obj/motor_pwm.o ghdl/obj/types.o
ghdl/obj/motor_commutator.o : ghdl/obj/motor_common.o ghdl/obj/types.o
ghdl/obj/motor_hall_speed.o : ghdl/obj/motor_common.o ghdl/obj/types.o
ghdl/obj/motor_pwm.o :
ghdl/obj/motors.o : ghdl/obj/commands.o ghdl/obj/motor.o ghdl/obj/motor_common.o ghdl/obj/types.o
ghdl/obj/readable_register.o : ghdl/obj/types.o
ghdl/obj/spi_master.o :
ghdl/obj/spi_slave_receiver.o : ghdl/obj/types.o ghdl/obj/utils.o
ghdl/obj/spi_slave_transmitter.o : ghdl/obj/types.o ghdl/obj/utils.o
ghdl/obj/spi_slave.o : ghdl/obj/spi_slave_receiver.o ghdl/obj/spi_slave_transmitter.o ghdl/obj/types.o
ghdl/obj/types.o :
ghdl/obj/writable_register.o : ghdl/obj/types.o
ghdl/obj/crc_step_test.o : ghdl/obj/types.o ghdl/obj/utils.o
ghdl/obj/spi_slave_test.o : ghdl/obj/spi_slave.o




##############################
# RULE FOR USAGE INFORMATION #
##############################

help :
	@echo "This is a multi-purpose Makefile which can do many things."
	@echo "To synthesize an Intel HEX file, run \"make synth\" or \"make synthesize\"."
	@echo "  (we expect to find the Xilinx settings{32,64}.sh file at $(XILINX_SETTINGS);"
	@echo "   if this path is wrong, please set the XILINX_SETTINGS environment variable"
	@echo "   to the correct path)"
	@echo "To just run the synthesis phase but not the mapper or anything after, run"
	@echo "  \"make xst\"."
	@echo "To run up to the mapper but not P&R or anything after, run \"make map\"."
	@echo "To run up to the P&R phase and then generate a timing report, run \"make trce\" or \"make trace\"."
	@echo "To run VHDL testbenches in GHDL, run \"make test\"."
	@echo "To run proofs of correctness in NuSMV, run \"make prove\"."
	@echo "To generate HTML documentation, run \"make doc\"."
	@echo "To remove all autogenerated files, run \"make clean\"."
.PHONY : help





##############################################
# RULE FOR GENERATING THE HTML DOCUMENTATION #
##############################################
doc :
	doxygen
.PHONY : doc





#######################
# RULES FOR SYNTHESIS #
#######################

# Targets to perform synthesis.
synth : synthesize
synthesize : $(PROJ).bin
xst : $(PROJ).ngc
map : $(PROJ)_map.ncd
trace : $(PROJ).tsi $(PROJ).twr $(PROJ).twx
trce : trace
.PHONY : synth synthesize xst map

# We can make a BIN file from a BIT file using Xilinx PROMGEN.
# Options:
#  -spi
#    Prevents reversing the bits in each byte (reversal is needed for parallel
#    Flash memories but not SPI memories).
#  -u 0 $(PROJ).bit
#    Inserts the BIT file into the generated image at address zero.
#  -p bin
#    Generates a raw binary file.
#  -s 2048
#    Generates data for a 2MB (16Mb) Flash.
#  -w
#    Overwrites any existing file.
$(PROJ).bin : $(PROJ).bit
	( source $(XILINX_SETTINGS) && promgen -spi -u 0 $(PROJ).bit -p bin -s 2048 -w )

# We can make a BIT file from a routed NCD file using Xilinx BITGEN.
# Options
#  -d
#    Skips DRC, since it's done by MAP/PAR anyway.
#  -g Compress
#    Packs data more efficiently, resulting in a smaller bitstream, without
#    altering the semantics of the bitstream.
#  -g DriveDone:1
#    Instructs the FPGA to drive the DONE pin high hard instead of leaving it to
#    float with a pull-up.
#  -g GTS_cycle:3
#    Instructs the FPGA to release the GLOBAL 3-STATE net in completion cycle 3.
#  -g LCK_cycle:4
#    Instructs the FPGA to wait for digital clock managers to synchronize in
#    completion cycle 4.
#  -g GWE_cycle:5
#    Instructs the FPGA to release the GLOBAL WRITE-ENABLE net to allow the
#    application to run in completion cycle 5.
#  -g DONE_cycle:6
#    Instructs the FPGA to raise the DONE pin in completion cycle 6.
#  -g UnusedPin:PULLUP
#    Instructs the FPGA to put pullup resistors on I/O pins not used by the
#    application.
#  -w
#    Overwrites any existing file.
$(PROJ).bit : $(PROJ).ncd
	( source $(XILINX_SETTINGS) && bitgen -d -g Compress -g DriveDone:yes -g GTS_cycle:3 -g LCK_cycle:4 -g GWE_cycle:5 -g DONE_cycle:6 -g UnusedPin:PULLUP $(PROJ).ncd $(PROJ).bit $(PROJ)_map.pcf -w )

# We can make a timing report file (in text and XML formats) and a timing specification interaction report from a routed NCD file and a physical constraints file using Xilinx Trace.
# Options
#  -v
#    Generates a verbose timing report.
#  -u
#    Reports unconstrained paths.
#  -tsi $(PROJ).tsi
#    Outputs a timing specification interaction report.
$(PROJ).tsi $(PROJ).twr $(PROJ).twx : $(PROJ).ncd $(PROJ)_map.pcf
	( source $(XILINX_SETTINGS) && trce -v -u -tsi $(PROJ).tsi $(PROJ).ncd $(PROJ)_map.pcf )

# We can make a routed NCD file from an unrouted NCD file using Xilinx PAR.
# Options
#  -w
#    Overwrites any existing file.
$(PROJ).ncd : $(PROJ)_map.ncd
	( source $(XILINX_SETTINGS) && par -mt $(PROCESSORS) $(PROJ)_map.ncd $(PROJ).ncd $(PROJ)_map.pcf -w )

# We can make an unrouted NCD file and a physical constraints file from an NGD file using Xilinx MAP.
# Options
#  -pr b
#    Uses flip-flops and latches built into the I/O pin drivers whenever
#    possible.
#  -w
#    Overwrites any existing file.
#  -detail
#    Generates a more detailed report file.
$(PROJ)_map.ncd $(PROJ)_map.pcf : $(PROJ).ngd
	( source $(XILINX_SETTINGS) && map -mt $(PROCESSORS) -pr b $(PROJ).ngd -o $(PROJ)_map.ncd -w -detail )

# We can make an NGD file from an NGC file and a UCF file using Xilinx NGDBUILD.
$(PROJ).ngd : $(PROJ).ngc $(PROJ).ucf
	( source $(XILINX_SETTINGS) && ngdbuild $(PROJ).ngc )

# We can make an NGC file from an XST file, a PRJ file, and a bunch of VHD files
# using Xilinx XST.
$(PROJ).ngc : $(PROJ).xst $(PROJ).prj $(Vs_common) $(VHDs_common) $(VHDs_synth)
	( source $(XILINX_SETTINGS) && xst -ifn $(PROJ).xst )





################################
# RULES FOR SIMULATION TESTING #
################################

# Target to invoke all the individual test-running rules.
test : $(addprefix test-,$(SIM_TARGETS))
.PHONY : test

# Make a list of all the .o files corresponding to the .vhds.
SIM_OBJS := $(patsubst %.vhd,ghdl/obj/%.o,$(notdir $(VHDs_common) $(VHDs_sim)))

# Template of code to generate for each simulation target.
define sim_target_template

# Target to run this simulation target.
test-$(1) : ghdl/bin/$(1)
	@mkdir -p ghdl/bin
	ghdl/bin/$(1) --stack-size=16777216 --ieee-asserts=disable
.PHONY : test-$(1)

# Target to elaborate the final executable.
ghdl/bin/$(1) : ghdl/obj/$(1).o
	@mkdir -p ghdl/bin
	cd ghdl/bin && ghdl -e --ieee=synopsys --workdir=../obj $(1)

endef

# Generate the per-simulation-target rules.
$(eval $(foreach target,$(SIM_TARGETS),$(call sim_target_template,$(target))))

# Template of code to analyze a VHD and generate an object file.
define sim_analyze_template

$(patsubst %.vhd,ghdl/obj/%.o,$(notdir $(1))) : $(1)
	@mkdir -p ghdl/obj
	ghdl -a --std=93c --ieee=synopsys --workdir=ghdl/obj $(1)

endef

# Generate the per-VHD rules.
$(eval $(foreach vhd,$(VHDs_common) $(VHDs_sim),$(call sim_analyze_template,$(vhd))))





#################################
# RULES FOR PROVING CORRECTNESS #
#################################

# Target to invoke all the individual proof-checking rules.
prove : $(addprefix prove-,$(notdir $(patsubst %.smv,%,$(SMVs))))
.PHONY : prove

# Template of code to generate for each proof file.
define prove_target_template

# Target to run this proof.
prove-$(notdir $(patsubst %.smv,%,$(1))) : $(1)
	NuSMV $(1)
.PHONY : prove-$(1)

endef

# Generate the per-proof-file rules.
$(eval $(foreach smv,$(SMVs),$(call prove_target_template,$(smv))))




#####################
# RULE FOR CLEANING #
#####################

clean :
	$(RM) *.bgn *.bit *.bld *.cfi *.drc *.html *.log *.lso *.lst *.map *.mcs *.mrp *.ncd *.ngc *.ngd *.ngm *_pad.csv *_pad.txt *.pad *.par *.pcf *.prm *.ptwx *.srp *.tsi *.twi *.twx *.unroutes *.xml *.xpi *.xrpt $(PROJ)_bd.bmm $(PROJ)_bitgen.xwbt $(PROJ)_vhdl.prj work-obj93.cf
	$(RM) -r ghdl html xlnx_auto_0_xdb xst _xmsgs
.PHONY : clean

