library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

library unisim;
use unisim.vcomponents.all;

entity Tester is
	port(
		-- The 2MHz Fosc/4 line from the PIC.
		PICOscillator : in std_ulogic;

		-- Serial lines to and from the XBee.
		XBeeRX : in std_ulogic;
		XBeeTX : out std_ulogic;

		-- SPI lines to and from the PIC.
		AppSS : in std_ulogic;
		AppOut : out std_ulogic;
		AppIn : in std_ulogic;
		AppClk : in std_ulogic;

		-- Control lines to and from the motor controllers.
		BrakeDrive : out std_ulogic;
		BrakeDribbler : out std_ulogic;
		PWM1 : out std_ulogic;
		PWM2 : out std_ulogic;
		PWM3 : out std_ulogic;
		PWM4 : out std_ulogic;
		PWMD : out std_ulogic;
		Dir1 : out std_ulogic;
		Dir2 : out std_ulogic;
		Dir3 : out std_ulogic;
		Dir4 : out std_ulogic;
		DirD : out std_ulogic;
		Fault1 : in std_ulogic;
		Fault2 : in std_ulogic;
		Fault3 : in std_ulogic;
		Fault4 : in std_ulogic;
		FaultD : in std_ulogic;
		DSense : in std_ulogic;

		-- Optical encoder phase lines.
		Encoder1A : in std_ulogic;
		Encoder1B : in std_ulogic;
		Encoder2A : in std_ulogic;
		Encoder2B : in std_ulogic;
		Encoder3A : in std_ulogic;
		Encoder3B : in std_ulogic;
		Encoder4A : in std_ulogic;
		Encoder4B : in std_ulogic;

		-- Break beam output line.
		BeamOut : out std_ulogic;

		-- Chicker control lines.
		ChickerCharge : out std_ulogic;
		ChickerDone : in std_ulogic;
		ChickerFault : in std_ulogic;
		ChickerKick : out std_ulogic;
		ChickerChip : out std_ulogic;

		-- The indicator LED.
		LED : out std_ulogic;

		-- Virtual rail lines.
		VGnd1 : out std_ulogic;
		VGnd2 : out std_ulogic;
		VGnd3 : out std_ulogic;
		VGnd4 : out std_ulogic;
		VGnd5 : out std_ulogic;
		VGnd6 : out std_ulogic;
		VGnd7 : out std_ulogic;
		VGnd8 : out std_ulogic;
		VVcc1 : out std_ulogic;
		VVcc2 : out std_ulogic;
		VVcc3 : out std_ulogic;
		VVcc4 : out std_ulogic
	);
end entity Tester;

architecture Behavioural of Tester is
	-- The clocks generated by the DCM from PICOscillator.
	signal Clock1 : std_ulogic;
	signal Clock100 : std_ulogic;

	-- Latched versions of all input pins other than PICOscillator.
	signal EncoderAL : std_ulogic_vector(1 to 4) := "0000";
	signal EncoderBL : std_ulogic_vector(1 to 4) := "0000";

	-- Encoder counts from the Gray counters.
	type EncoderCountType is array(1 to 4) of signed(12 downto 0);
	signal EncoderCount : EncoderCountType;

	-- Motor powers from the controller or direct drive.
	type MotorType is array(1 to 4) of unsigned(10 downto 0);
	signal Motor : MotorType;

	-- PWM signals from the PWM generators.
	signal PWM : std_ulogic_vector(1 to 4) := "0000";

	-- Radio stuff.
	signal XBeeData : std_ulogic_vector(7 downto 0);
	signal XBeeLoad : std_ulogic := '0';
	signal XBeeSOP : std_ulogic := '0';
	signal XBeeBusy : std_ulogic;
	signal SerialData : std_ulogic_vector(7 downto 0);
	signal SerialLoad : std_ulogic;
	signal SerialBusy : std_ulogic;
	signal ClearChecksum : boolean := false;
	signal Checksum : unsigned(7 downto 0);

	-- Data storage.
	type RAMType is array(0 to 1023) of std_ulogic_vector(17 downto 0);
	signal RAM1 : RAMType;
	signal RAM2 : RAMType;
	signal RAM3 : RAMType;
	signal RAM1Data : std_ulogic_vector(17 downto 0);
	signal RAM2Data : std_ulogic_vector(17 downto 0);
	signal RAM3Data : std_ulogic_vector(17 downto 0);

	-- State machine.
	type StateType is (Quiescing, Executing, Uploading);
	signal State : StateType := Quiescing;
	constant SampleRate : natural := 50000;
	subtype SampleRateCounterType is natural range 0 to SampleRate - 1;
	signal SampleRateCounter : SampleRateCounterType := 1;
	constant PacketRate : natural := 25000;
	subtype PacketCounterType is natural range 0 to PacketRate - 1;
	signal PacketCounter : PacketCounterType := 0;
	type PacketStateType is (WaitPacketCounter, SendSOP, SendLengthMSB, SendLengthLSB, SendAPIID, SendFrameID, SendAddressMSB, SendAddressLSB, SendOptions, SendIndex, SendData1, SendData2, SendData3, SendData4, SendData5, SendData6, SendData7, SendData8, SendChecksum);
	signal PacketState : PacketStateType := WaitPacketCounter;
	signal RAMPointer : natural range 0 to 1023 := 0;
	signal ResetEncoders : std_ulogic := '1';

	-- Test generator stuff.
	subtype SquareWaveCounterType is natural range 0 to 19;
	signal SquareWaveCounter : SquareWaveCounterType := 0;
begin
	-- Pass the PICOscillator pin through a DCM to get the final clocks.
	ClockGenInstance : entity work.ClockGen(Behavioural)
	port map(
		PICOscillator => PICOscillator,
		Clock100 => Clock100,
		Clock10 => open,
		Clock1 => Clock1
	);

	-- Latch the inputs into the local signals.
	process(Clock1)
	begin
		if rising_edge(Clock1) then
			EncoderAL(1) <= Encoder1A;
			EncoderAL(2) <= Encoder2A;
			EncoderAL(3) <= Encoder3A;
			EncoderAL(4) <= Encoder4A;
			EncoderBL(1) <= Encoder1B;
			EncoderBL(2) <= Encoder2B;
			EncoderBL(3) <= Encoder3B;
			EncoderBL(4) <= Encoder4B;
		end if;
	end process;

	-- Serial communication hardware.
	SerialTransmitter : entity work.SerialTransmitter(Behavioural)
	port map(
		Clock1 => Clock1,
		Data => SerialData,
		Load => SerialLoad,
		Busy => SerialBusy,
		Serial => XBeeTX
	);
	XBeeByteTransmitter : entity work.XBeeByteTransmitter(Behavioural)
	port map(
		Clock1 => Clock1,
		Data => XBeeData,
		Load => XBeeLoad,
		SOP => XBeeSOP,
		Busy => XBeeBusy,
		SerialData => SerialData,
		SerialLoad => SerialLoad,
		SerialBusy => SerialBusy
	);

	-- Braking stuff.
	BrakeDrive <= '0';
	BrakeDribbler <= '1';

	-- Wheel stuff.
	GrayCounters : for I in 1 to 4 generate
	begin
		Instance : entity work.GrayCounter(Behavioural)
		generic map(
			Width => 13,
			Sign => -1
		)
		port map(
			Clock1 => Clock1,
			A => EncoderAL(I),
			B => EncoderBL(I),
			Reset => ResetEncoders,
			Count => EncoderCount(I)
		);
	end generate;

	process(Clock1)
		variable TickSampleRateCounter : boolean := false;
		variable TickRAMPointer : boolean := false;
	begin
		if rising_edge(Clock1) then
			if ClearChecksum then
				Checksum <= X"FF";
			elsif XBeeLoad = '1' then
				Checksum <= Checksum - unsigned(XBeeData);
			end if;

			ClearChecksum <= false;
			TickSampleRateCounter := false;
			TickRAMPointer := false;
			XBeeLoad <= '0';
			XBeeSOP <= '0';
			ResetEncoders <= '0';

			if State = Quiescing then
				if SampleRateCounter = 0 then
					State <= Executing;
				end if;
				TickSampleRateCounter := true;
				ResetEncoders <= '1';
			elsif State = Executing then
				if SampleRateCounter = 0 then
					RAM1(RAMPointer) <= "0" & std_ulogic_vector(EncoderCount(4)(3 downto 0)) & std_ulogic_vector(EncoderCount(1)(12 downto 0));
					RAM2(RAMPointer) <= "0" & std_ulogic_vector(EncoderCount(4)(7 downto 4)) & std_ulogic_vector(EncoderCount(2)(12 downto 0));
					RAM3(RAMPointer) <= std_ulogic_vector(EncoderCount(4)(12 downto 8)) & std_ulogic_vector(EncoderCount(3)(12 downto 0));
					ResetEncoders <= '1';
					if RAMPointer = 1023 then
						State <= Uploading;
					end if;
					TickRAMPointer := true;
					SquareWaveCounter <= (SquareWaveCounter + 1) mod (SquareWaveCounterType'high + 1);
				end if;
				TickSampleRateCounter := true;
			elsif State = Uploading then
				if XBeeBusy = '0' then
					if PacketState = WaitPacketCounter then
						if PacketCounter = 0 then
							PacketCounter <= PacketCounterType'high;
							PacketState <= SendSOP;
						else
							PacketCounter <= PacketCounter - 1;
						end if;
					elsif PacketState = SendSOP then
						XBeeSOP <= '1';
						PacketState <= SendLengthMSB;
					elsif PacketState = SendLengthMSB then
						XBeeData <= X"00";
						XBeeLoad <= '1';
						PacketState <= SendLengthLSB;
					elsif PacketState = SendLengthLSB then
						XBeeData <= X"46";
						XBeeLoad <= '1';
						ClearChecksum <= true;
						PacketState <= SendAPIID;
					elsif PacketState = SendAPIID then
						XBeeData <= X"01";
						XBeeLoad <= '1';
						PacketState <= SendFrameID;
					elsif PacketState = SendFrameID then
						XBeeData <= X"00";
						XBeeLoad <= '1';
						PacketState <= SendAddressMSB;
					elsif PacketState = SendAddressMSB then
						XBeeData <= X"00";
						XBeeLoad <= '1';
						PacketState <= SendAddressLSB;
					elsif PacketState = SendAddressLSB then
						XBeeData <= X"00";
						XBeeLoad <= '1';
						PacketState <= SendOptions;
					elsif PacketState = SendOptions then
						XBeeData <= X"00";
						XBeeLoad <= '1';
						PacketState <= SendIndex;
					elsif PacketState = SendIndex then
						XBeeData <= std_ulogic_vector(to_unsigned(RAMPointer / 8, 8));
						XBeeLoad <= '1';
						PacketState <= SendData1;
					elsif PacketState = SendData1 then
						XBeeData <= std_ulogic_vector(resize(signed(RAM1Data(12 downto 0)), 16)(7 downto 0));
						XBeeLoad <= '1';
						PacketState <= SendData2;
					elsif PacketState = SendData2 then
						XBeeData <= std_ulogic_vector(resize(signed(RAM1Data(12 downto 0)), 16)(15 downto 8));
						XBeeLoad <= '1';
						PacketState <= SendData3;
					elsif PacketState = SendData3 then
						XBeeData <= std_ulogic_vector(resize(signed(RAM2Data(12 downto 0)), 16)(7 downto 0));
						XBeeLoad <= '1';
						PacketState <= SendData4;
					elsif PacketState = SendData4 then
						XBeeData <= std_ulogic_vector(resize(signed(RAM2Data(12 downto 0)), 16)(15 downto 8));
						XBeeLoad <= '1';
						PacketState <= SendData5;
					elsif PacketState = SendData5 then
						XBeeData <= std_ulogic_vector(resize(signed(RAM3Data(12 downto 0)), 16)(7 downto 0));
						XBeeLoad <= '1';
						PacketState <= SendData6;
					elsif PacketState = SendData6 then
						XBeeData <= std_ulogic_vector(resize(signed(RAM3Data(12 downto 0)), 16)(15 downto 8));
						XBeeData <= "000" & RAM3Data(12 downto 8);
						XBeeLoad <= '1';
						PacketState <= SendData7;
					elsif PacketState = SendData7 then
						XBeeData <= std_ulogic_vector(resize(signed(std_ulogic_vector'(RAM3Data(17 downto 13) & RAM2Data(16 downto 13) & RAM1Data(16 downto 13))), 16)(7 downto 0));
						XBeeLoad <= '1';
						PacketState <= SendData8;
					elsif PacketState = SendData8 then
						XBeeData <= std_ulogic_vector(resize(signed(std_ulogic_vector'(RAM3Data(17 downto 13) & RAM2Data(16 downto 13) & RAM1Data(16 downto 13))), 16)(15 downto 8));
						XBeeLoad <= '1';
						TickRAMPointer := true;
						if RAMPointer mod 8 = 7 then
							PacketState <= SendChecksum;
						else
							PacketState <= SendData1;
						end if;
					elsif PacketState = SendChecksum then
						XBeeData <= std_ulogic_vector(Checksum);
						XBeeLoad <= '1';
						PacketState <= WaitPacketCounter;
					end if;
				end if;
			end if;

			if TickSampleRateCounter then
				SampleRateCounter <= (SampleRateCounter + 1) mod (SampleRateCounterType'high + 1);
			end if;

			if TickRAMPointer then
				RAMPointer <= (RAMPointer + 1) mod 1024;
			end if;

			RAM1Data <= RAM1(RAMPointer);
			RAM2Data <= RAM2(RAMPointer);
			RAM3Data <= RAM3(RAMPointer);
		end if;
	end process;

	Motor(1) <= to_unsigned(200, 11) when SquareWaveCounter < ((SquareWaveCounterType'high + 1) / 2) and State = Executing else to_unsigned(0, 11);
	Motor(2) <= to_unsigned(0, 11);
	Motor(3) <= to_unsigned(0, 11);
	Motor(4) <= to_unsigned(0, 11);

	PWMs : for I in 1 to 4 generate
	begin
		Instance : entity work.PWM(Behavioural)
		generic map(
			Width => 10,
			Invert => true
		)
		port map(
			Clock100 => Clock100,
			DutyCycle => Motor(I)(9 downto 0),
			PWM => PWM(I)
		);
	end generate;
	PWM1 <= PWM(1);
	PWM2 <= PWM(2);
	PWM3 <= PWM(3);
	PWM4 <= PWM(4);

	Dir1 <= Motor(1)(10);
	Dir2 <= Motor(2)(10);
	Dir3 <= Motor(3)(10);
	Dir4 <= Motor(4)(10);

	-- Dribbler stuff.
	PWMD <= '1';
	DirD <= '0';

	-- The SPI receiver for the analogue to digital converters.
	AppOut <= '0';

	-- Break beam output line.
	BeamOut <= '1';

	-- Chicker control stuff.
	ChickerCharge <= '1';
	ChickerKick <= '1';
	ChickerChip <= '1';

	-- The indicator LED.
	LED <= '0' when State = Uploading else '1';

	-- Virtual rail lines.
	VGnd1 <= '0';
	VGnd2 <= '0';
	VGnd3 <= '0';
	VGnd4 <= '0';
	VGnd5 <= '0';
	VGnd6 <= '0';
	VGnd7 <= '0';
	VGnd8 <= '0';
	VVcc1 <= '1';
	VVcc2 <= '1';
	VVcc3 <= '1';
	VVcc4 <= '1';
end architecture Behavioural;
