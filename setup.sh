#!/usr/bin/env bash
# Sets up a clone of all the Electrical repos for you

REPOS=(
	'UBC-ThunderBots/PCB_Encoder'
	'UBC-ThunderBots/PCB_EStop'
	'UBC-ThunderBots/PCB_MotorDriver'
	'UBC-ThunderBots/PCB_NucleoClone'
	'UBC-Thunderbots/PCB_Oven'
	'UBC-ThunderBots/PCB_Power'
	'UBC-ThunderBots/PCB_RMII_Dongle'
	'UBC-ThunderBots/PCB_Template'
	'UBC-ThunderBots/PCB_Wifi'
)
CHECK_SUBMODULE='Altium_Libraries'

# END configuration

set -o errexit
set -o nounset
cd "$(dirname "$0")"

HOOK_HEADER='#!/usr/bin/env bash'

HOOK_BODY="$(cat <<'EOF'
sm_branch=$(git config --get "submodule.${check_path}.branch")

# if branch is not set in config, it will be master
# git source: https://github.com/git/git/blob/20514004ddf1a3528de8933bc32f284e175e1012/builtin/submodule--helper.c#L1984
sm_branch="${sm_branch:-master}"

# if the submodule is not here, allow all pushes
if [[ ! -d "${check_path}" ]]; then
	exit 0
fi
cd "${check_path}"

red=$'\e[31m'
bold=$'\e[1m'
nobold=$'\e[22m'
norm=$'\e[0m'

# check if there are any untracked/not committed/etc files in the
# local repo first (fastest to check fail case)

if [[ -n "$(git status --porcelain)" ]]; then
	echo "${red}!! ${bold}${check_path}${nobold} has changes that are not checked in${norm}" >&2
	git status -u
	exit 1
fi

# check if the remote git repo is different from the local clone
# this calls out to the network but that is acceptable in this context
# since you cannot deploy without network access

# source: https://stackoverflow.com/a/17938274
git fetch
if [[ ! $(git rev-parse HEAD) == $(git rev-parse "${sm_branch}@{u}") ]]; then
	echo "${red}!! ${bold}${check_path}${nobold} is not the same as remote${norm}" >&2
	echo "Help: run ${bold}git submodule update --remote${norm} to update ${bold}${check_path}${norm} and double check everything is OK before committing and pushing" >&2
	exit 1
else
	exit 0
fi
EOF
)"

red=$'\e[31m'
bold=$'\e[1m'
nobold=$'\e[22m'
norm=$'\e[0m'

# check if the user has ssh access to github set up
# ssh will return 255 if there's no key, else 1
echo ':: Checking if you have ssh keys set up with GitHub' >&2
ssh git@github.com >/dev/null 2>&1 && res=$? || res=$?
if [[ ${res} == 1 ]]; then
	echo ":: Cloning with ${bold}ssh${norm}" >&2
	use_ssh=1
else
	echo ":: Cloning with ${bold}https${norm}" >&2
	use_ssh=0
fi

function join_by { local IFS="$1"; shift; echo "$*"; }

function repo_url {
	if [[ ${use_ssh} -eq 1 ]]; then
		echo "git@github.com:${1}"
	else
		echo "https://github.com/${1}"
	fi
}

# insert hook that checks ${2} into repo ${1}
function insert_hook {
	local quoted_check_path="$(printf '%q' "${2}")"
	local hook_path="${1}/.git/hooks/pre-push"
	echo "${HOOK_HEADER}" > "${hook_path}"
	echo "check_path=${quoted_check_path}" >> "${hook_path}"
	echo "${HOOK_BODY}" >> "${hook_path}"
	chmod +x "${hook_path}"
}

function setup_gitignore {
	local block_contents="$(
		for repo in "${REPOS[@]}"; do
			echo "${repo##*/}/"
		done
	)"
	echo ":: Updating gitignore" >&2

	# TODO: figure out how to initialize gitignores anew
	ex .gitignore >/dev/null 2>&1 <<-END
	/^# BEGIN setup.sh AUTOGENERATED$/,/^# END setup.sh AUTOGENERATED$/c
	# BEGIN setup.sh AUTOGENERATED
	${block_contents}
	# END setup.sh AUTOGENERATED
	.
	w!
	q
	END
}

setup_gitignore

for repo in "${REPOS[@]}"; do
	# knock off the longest */ match from the string, getting the last component of it
	# e.g. a/b/c turns into c
	dir_name="${repo##*/}"

	# skip already cloned repo
	if [[ -d "${dir_name}" ]]; then
		echo ":: Skipping cloning already cloned ${bold}${dir_name}${norm}" >&2
	else
		url="$(repo_url "${repo}")"
		echo ":: Cloning ${bold}${repo}${norm} from ${bold}${url}${norm}" >&2
		git clone --recursive "${url}" "${dir_name}"
	fi

	insert_hook "${dir_name}" "${CHECK_SUBMODULE}"
done
