#!/usr/bin/env python3

import asyncio
import argparse
import enum
import functools
import os
from pathlib import Path
import subprocess
import sys


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def whereami():
    """
    Returns the path to where we are installed
    """
    return Path(__file__).parent

def get_repos():
    """
    Grabs a list of the repos we are tracking.
    """
    configfile = whereami() / 'repos.txt'
    config = []
    with configfile.open('r') as h:
        for line in h.readlines():
            stripped = line.strip()
            if stripped == '':
                # ignore empty lines
                continue

            # split off local part
            url, _, name = stripped.partition(' ')
            config.append((url, name))
    return config


class RepoStatus(enum.Enum):
    UNTRACKED    = enum.auto()
    UP_TO_DATE   = enum.auto()
    REMOTE_AHEAD = enum.auto()
    LOCAL_AHEAD  = enum.auto()
    UNKNOWN      = enum.auto()


async def get_status(repo):
    """
    Return whether a given repo is up to date, behind, or has untracked files.
    Relies on you being in the whereami() directory.
    """
    status = await gitcmd(['status', '--porcelain'], chdir=repo, err_ok=True)
    if status != 0:
        # git status returns nonzero if there are untracked files
        return RepoStatus.UNTRACKED

    status = await gitcmd(['fetch'], chdir=repo, err_ok=True)
    if status != 0:
        # Ignore errors and just fail to find status if we can't contact remote
        return RepoStatus.UNKNOWN

    local_is_ancestor, remote_is_ancestor = await asyncio.gather(
        gitcmd(['merge-base', '--is-ancestor', 'HEAD', '@{u}'],
                chdir=repo, err_ok=True),
        gitcmd(['merge-base', '--is-ancestor', '@{u}', 'HEAD'],
                chdir=repo, err_ok=True)
    )

    if remote_is_ancestor == 0 and local_is_ancestor == 0:
        # if both of them are ancestors of themselves then they are the same
        # commit
        return RepoStatus.UP_TO_DATE
    elif remote_is_ancestor == 1 and local_is_ancestor == 0:
        # remote is NOT ancestor of local but local is ancestor of remote
        # This means that local is ahead.
        return RepoStatus.REMOTE_AHEAD
    elif remote_is_ancestor == 0 and local_is_ancestor == 1:
        # remote is ancestor of local and local is NOT ancestor of remote
        # This means that remote is ahead
        return RepoStatus.LOCAL_AHEAD
    else:
        return RepoStatus.UNKNOWN



async def run_cmd(executable, cmd, cb = lambda: None,
                  chdir = None, err_ok = False):
    #eprint('Executing', *cmd, 'in', chdir)
    proc = await asyncio.create_subprocess_exec(executable, *cmd, cwd=chdir)
    retcode = await proc.wait()
    if retcode != 0 and not err_ok:  # EXIT_SUCCESS
        eprint('Command', *cmd, 'exited with a failure status code', retcode)
    cb()
    return retcode


gitcmd = functools.partial(run_cmd, 'git')


def update_gitignore(repos):
    """
    Adds all the repositories to gitignore idempotently if installed in the
    root of a git repo
    """
    SIGNATURE = b'### AUTOGENERATED ignores from repo.py, content below ' \
                b'*will* be overwritten ###\n'
    cwd = Path('.')
    if not (cwd / '.git').is_dir():
        # we are not in the root of a git working tree, don't screw it up
        return

    # we have to open this file in binary format because of the extremely
    # surprising behaviour described in https://bugs.python.org/issue26158
    with open('.gitignore', 'rb+') as h:
        need_sig = True

        # move the position in the stream to after our signature
        while True:
            line = h.readline()
            if line == b'':
                break
            if line == SIGNATURE:
                need_sig = False
                break

        h.truncate(h.tell())
        if need_sig:
            h.write(SIGNATURE)
        for repo in repos:
            h.write(repo[1].encode() + b'/\n')


async def cli_init(args):
    github_url = 'https://github.com/' if args.https else 'git@github.com:'

    repos = get_repos()
    update_gitignore(repos)

    # TODO: only fetch some repos at once
    total = len(repos)
    eprint(f"Initializing {total} repos")
    os.chdir(whereami())
    done = 0

    def finished():
        nonlocal done
        done += 1
        eprint(f"Completed {done}/{total}")

    jobs = []
    for (gh, directory) in repos:
        # Don't clone repos that exist
        if Path(directory).exists():
            eprint(f'Skipping already initialized {directory}')
            continue
        jobs.append(gitcmd(['clone', '--quiet', github_url + gh,
                                directory], cb=finished))
    await asyncio.gather(*jobs)


async def cli_pull(args):
    repos = get_repos()
    os.chdir(whereami())

    total = len(repos)
    done = 0
    def finished():
        nonlocal done
        done += 1
        eprint(f"Completed {done}/{total}")

    jobs = []
    for (_, directory) in repos:
        # Don't mess with repos that haven't been cloned yet
        if not Path(directory).exists():
            eprint(f'Warning: {repo[1]} is not cloned yet. '
                    'Run `./repo.py init` to fix this.')
            continue
        jobs.append(gitcmd(['pull', '--quiet', '--no-ff'], cb=finished,
                               chdir=directory))
    await asyncio.gather(*jobs)


STATUS_COLOURS = {
    RepoStatus.UNKNOWN:      '\x1b[31m',  # red
    RepoStatus.UP_TO_DATE:   '\x1b[32m',  # green
    RepoStatus.LOCAL_AHEAD:  '\x1b[35m',  # purple
    RepoStatus.REMOTE_AHEAD: '\x1b[33m',  # yellow
}

STATUS_NAMES = {
    RepoStatus.UNKNOWN:      'unknown   ',  # red
    RepoStatus.UP_TO_DATE:   'up to date',  # green
    RepoStatus.LOCAL_AHEAD:  'needs push',  # purple
    RepoStatus.REMOTE_AHEAD: 'needs pull',  # yellow
}

async def cli_status(args):
    RESET  = '\x1b[0m'

    repos = get_repos()
    os.chdir(whereami())

    jobs = []
    for (_, directory) in repos:
        jobs.append(get_status(directory))

    statuses = await asyncio.gather(*jobs)
    for idx, status in enumerate(statuses):
        print(STATUS_COLOURS[status], STATUS_NAMES[status], RESET, '\t',
                repos[idx][1], sep='')


async def cli_forall(args):
    repos = get_repos()

    total = len(repos)
    os.chdir(whereami())
    done = 0

    def finished():
        nonlocal done
        done += 1
        eprint(f"Completed {done}/{total}")

    tasks = []
    for (_, directory) in repos:
        tasks.append(run_cmd(args.run[0], args.run[1:], chdir=directory,
                             cb=finished))
    await asyncio.gather(*tasks)

def main():
    async def fail(*args):
        raise ValueError('Subcommand not specified')

    ap = argparse.ArgumentParser()
    ap.set_defaults(cmd=fail)
    sps = ap.add_subparsers()

    init_parser = sps.add_parser('init')
    init_parser.set_defaults(cmd=cli_init)
    init_parser.add_argument('--https', action='store_true',
            help='Clone repos with https rather than ssh')

    pull_parser = sps.add_parser('pull')
    pull_parser.set_defaults(cmd=cli_pull)

    status_parser = sps.add_parser('status')
    status_parser.set_defaults(cmd=cli_status)

    forall_parser = sps.add_parser('forall')
    forall_parser.set_defaults(cmd=cli_forall)
    forall_parser.add_argument('run', nargs='+', help='Command to run')

    args = ap.parse_args()
    asyncio.run(args.cmd(args))

if __name__ == '__main__':
    main()
